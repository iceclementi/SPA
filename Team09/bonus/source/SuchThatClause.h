#pragma once

#include "QueryArgument.h"
#include "QueryClause.h"

using namespace std;

/*
* Enum to describe a possible such-that relationship type
*/
enum class SUCH_THAT_REL_TYPE {
	MODIFIES, USES, CALLS, CALLS_T, PARENT, PARENT_T, FOLLOWS, FOLLOWS_T, NEXT, NEXT_T, AFFECTS, AFFECTS_T, NEXTBIP, NEXTBIP_T, AFFECTSBIP, AFFECTSBIP_T, INVALID
};

/*
* Stores a mapping of such-that relationship type string to such-that relationship type enum
*/
static unordered_map<string, SUCH_THAT_REL_TYPE> mapStrToSuchThatRelType = {
	{"Modifies", SUCH_THAT_REL_TYPE::MODIFIES},
	{"Uses", SUCH_THAT_REL_TYPE::USES},
	{"Calls", SUCH_THAT_REL_TYPE::CALLS},
	{"Calls*", SUCH_THAT_REL_TYPE::CALLS_T},
	{"Parent", SUCH_THAT_REL_TYPE::PARENT},
	{"Parent*", SUCH_THAT_REL_TYPE::PARENT_T},
	{"Follows", SUCH_THAT_REL_TYPE::FOLLOWS},
	{"Follows*", SUCH_THAT_REL_TYPE::FOLLOWS_T},
	{"Next", SUCH_THAT_REL_TYPE::NEXT},
	{"Next*", SUCH_THAT_REL_TYPE::NEXT_T},
	{"Affects", SUCH_THAT_REL_TYPE::AFFECTS},
	{"Affects*", SUCH_THAT_REL_TYPE::AFFECTS_T},
	{"NextBip", SUCH_THAT_REL_TYPE::NEXTBIP},
	{"NextBip*", SUCH_THAT_REL_TYPE::NEXTBIP_T},
	{"AffectsBip", SUCH_THAT_REL_TYPE::AFFECTSBIP},
	{"AffectsBip*", SUCH_THAT_REL_TYPE::AFFECTSBIP_T}
};

/*
* Stores a mapping of such-that relationship type enum to valid argument type enums for each argument
*/
static unordered_map<SUCH_THAT_REL_TYPE, vector<set<ARGUMENT_TYPE>>> mapSuchThatRelTypeToArgsTypes = {
	{SUCH_THAT_REL_TYPE::MODIFIES,
		{
			{ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::USES,
		{
			{ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::CALLS,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::CALLS_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::IDENT, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::PARENT,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::PARENT_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::FOLLOWS,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::FOLLOWS_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXT,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXT_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTS,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTS_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXTBIP,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXTBIP_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTSBIP,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTSBIP_T,
		{
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM},
			{ARGUMENT_TYPE::UNDERSCORE, ARGUMENT_TYPE::INTEGER, ARGUMENT_TYPE::SYNONYM}
		}
	}
};

/*
* Stores a mapping of such-that relationship type enum to valid synonym type enums for each argument of synonym type
*/
static unordered_map<SUCH_THAT_REL_TYPE, vector<set<DESIGN_ENTITY>>> mapSuchThatRelTypeToArgsSynTypes = {
	{SUCH_THAT_REL_TYPE::MODIFIES,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE, DESIGN_ENTITY::PROCEDURE},
			{DESIGN_ENTITY::VARIABLE}
		}
	},
	{SUCH_THAT_REL_TYPE::USES,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE, DESIGN_ENTITY::PROCEDURE},
			{DESIGN_ENTITY::VARIABLE}
		}
	},
	{SUCH_THAT_REL_TYPE::CALLS,
		{
			{DESIGN_ENTITY::PROCEDURE},
			{DESIGN_ENTITY::PROCEDURE}
		}
	},
	{SUCH_THAT_REL_TYPE::CALLS_T,
		{
			{DESIGN_ENTITY::PROCEDURE},
			{DESIGN_ENTITY::PROCEDURE}
		}
	},
	{SUCH_THAT_REL_TYPE::PARENT,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::PARENT_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::FOLLOWS,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::FOLLOWS_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXT,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXT_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTS,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTS_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXTBIP,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::NEXTBIP_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::READ, DESIGN_ENTITY::PRINT, DESIGN_ENTITY::CALL, DESIGN_ENTITY::WHILE, DESIGN_ENTITY::IF, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTSBIP,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	},
	{SUCH_THAT_REL_TYPE::AFFECTSBIP_T,
		{
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE},
			{DESIGN_ENTITY::STATEMENT, DESIGN_ENTITY::ASSIGN, DESIGN_ENTITY::PROG_LINE}
		}
	}
};

/*
* Represents a such-that clause in a query
* 
* Example: "assign a, b; Select a such that Follows(a, b)" is stored as:
* clauseType = CLAUSE_TYPE::SUCH_THAT
* relType: SUCH_THAT_REL_TYPE::FOLLOWS
* firstArg = { NO_ERROR, ARGUMENT_TYPE::SYNONYM, "a", { NO_ERROR, 1, DESIGN_ENTITY::ASSIGN, ATTRIBUTE_TYPE::NONE } }
* secondArg = { NO_ERROR, ARGUMENT_TYPE::SYNONYM, "b", { NO_ERROR, 2, DESIGN_ENTITY::ASSIGN, ATTRIBUTE_TYPE::NONE } }
*/
class SuchThatClause : public QueryClause {
	CLAUSE_TYPE clauseType = CLAUSE_TYPE::SUCH_THAT;

public:
	SuchThatClause();
	SuchThatClause(SUCH_THAT_REL_TYPE relType, QueryArgument firstArg, QueryArgument secondArg);

	SUCH_THAT_REL_TYPE relType = SUCH_THAT_REL_TYPE::INVALID;
	QueryArgument firstArg;
	QueryArgument secondArg;
};

inline
bool operator== (SuchThatClause lhs, SuchThatClause rhs) {
	return lhs.getClauseSynonyms() == rhs.getClauseSynonyms() &&
		lhs.relType == rhs.relType &&
		lhs.firstArg == rhs.firstArg &&
		lhs.secondArg == rhs.secondArg;
}
